# CVE-2024-30084

## Windows Kernel Streaming WOW Thunk Service Driver Elevation of Privilege Vulnerability (TOCTOU)

### Analysis

#### Before:

```C
NTSTATUS __fastcall CKSAutomationThunk::ThunkPropertyIrp(struct _LIST_ENTRY *a1, IRP *a2, __int64 a3, NTSTATUS *ret)
{
  struct _IO_STACK_LOCATION *pCSP; // rax
  SIZE_T inputLen; // rdx
  ULONG *userBuf; // rsi
  NTSTATUS status; // eax

  pCSP = a2->Tail.Overlay.CurrentStackLocation;
  inputLen = pCSP->Parameters.DeviceIoControl.InputBufferLength;
  userBuf = (ULONG *)pCSP->Parameters.DeviceIoControl.Type3InputBuffer; [1]
  if ( !a2->AssociatedIrp.MasterIrp )
  {
    if ( (unsigned int)inputLen < 0x18 )
    {
      *ret = STATUS_INVALID_BUFFER_SIZE;
      return 0;
    }
    if ( a2->RequestorMode )
      ProbeForRead(pCSP->Parameters.DeviceIoControl.Type3InputBuffer, inputLen, 1u); [2]
    if ( (userBuf[5] & 3) != 0 ) [3]
    {
      a2->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Blink = a1;
      status = KsPropertyHandler(a2, 6u, &PropertySet);
      if ( status != (unsigned int)STATUS_NOT_FOUND && status != (unsigned int)STATUS_PROPSET_NOT_FOUND )
      {
        *ret = status;
        return 0;
      }
    }
  }
  return 1;
}
```

#### After:

```C
__int64 __fastcall CKSAutomationThunk::ThunkPropertyIrp(
        struct _LIST_ENTRY *a1,
        IRP *a2,
        __int64 a3,
        NTSTATUS *return_status)
{
  struct _IO_STACK_LOCATION *CurrentStackLocation; // rdi
  SIZE_T inputBufferLength; // rsi
  _DWORD *Type3InputBuffer; // rdi
  NTSTATUS status; // eax

  CurrentStackLocation = a2->Tail.Overlay.CurrentStackLocation;
  inputBufferLength = CurrentStackLocation->Parameters.DeviceIoControl.InputBufferLength;
  if ( (unsigned int)Feature_996843837__private_IsEnabledDeviceUsage() )
  {
    if ( a2->AssociatedIrp.MasterIrp )
      return 1LL;
    if ( (unsigned int)inputBufferLength >= 0x18 )
    {
      if ( a2->RequestorMode )
        ProbeForRead(
          CurrentStackLocation->Parameters.DeviceIoControl.Type3InputBuffer,
          (unsigned int)inputBufferLength,
          1u);
      if ( (*((_DWORD *)CurrentStackLocation->Parameters.DeviceIoControl.Type3InputBuffer + 5) & 3) == 0 )
        return 1LL;
LABEL_15:
      a2->Tail.Overlay.DeviceQueueEntry.DeviceListEntry.Blink = a1;
      status = KsPropertyHandler(a2, 6u, &PropertySet);
      if ( status != (unsigned int)STATUS_NOT_FOUND && status != (unsigned int)STATUS_PROPSET_NOT_FOUND )
      {
        *return_status = status;
        return 0LL;
      }
      return 1LL;
    }
  }
  else
  {
    Type3InputBuffer = CurrentStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;
    if ( a2->AssociatedIrp.MasterIrp )
      return 1LL;
    if ( (unsigned int)inputBufferLength >= 0x18 )
    {
      if ( a2->RequestorMode )
        ProbeForRead(Type3InputBuffer, inputBufferLength, 1u);
      if ( (Type3InputBuffer[5] & 3) == 0 )
        return 1LL;
      goto LABEL_15;
    }
  }
  *return_status = STATUS_INVALID_BUFFER_SIZE;
  return 0LL;
}
```

The code previously suffered from a race condition (**Time-of-Check to Time-of-Use**) vulnerability because it copied the user-mode pointer `Type3InputBuffer` to a local variable but did not probe it. Specifically, it probed one pointer but accessed another, potentially allowing an attacker to exploit the window between validation and use by pointing to another location in memory after bypassing the checks that would then lead to privilege escalation by chaining it with untrusted pointer dereference.

The patch aims to fix this race condition by ensuring that the pointer used during probing is the same as the one used for accessing the data, thereby closing the window of opportunity for an attacker to alter the data between validation and use.

### Credits

- Vulnerability discovery: Angelboy (@scwuaptx)
- Vulnerability analysis: Nero22k
